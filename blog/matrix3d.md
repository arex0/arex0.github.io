---
title: "CSS matrix3d 旋转3D物体（原理篇）"
keywords: [CSS,3D]
description: "use css matrix3d rotate object in 3d"
created: "2020-04-06"
modified: "2020-04-09"
markdown: true
share: true
---

# CSS matrix3d 旋转3D物体（原理篇）
***让3d物体按照用户想法，跟随指尖旋转***

## 前言
我在设计页面的时候，试图从3d的角度审视页面组件，因此构建了app [design 3d](/apps/design)。但是简单的右滑绕Y轴旋转逻辑并不正确。在绕Z轴旋转`180deg`后，Y轴反转了。我猛然醒悟，原来需要矩阵运算！！！
## 开始
### 2d 页面坐标系
在笛卡尔坐标系中，每个 欧氏空间 里的点都由横坐标和纵坐标这两个值来确定。 在CSS（和大部分的计算机图形学）中，原点 (0, 0) 在元素的左上角。每个点都使用数学上的向量符号(x,y)来描述。
```
        x
    +------->
    | 
  y |   html
    |
    v
```
此时X轴指向右边，Y轴指向下方。所以`translateX(10px)`会让元素向右平移`10px`。
### matrix2d
CSS 函数 matrix() 用六个指定的值来指定一个均匀的二维（2D）变换矩阵。这个矩形中的常量值是不作为参数进行传递的，其他的参数顺序和主列顺序一致。
```
matrix(a,b,c,d,tx,ty)
=== matrix2d(a,b,0,c,d,0,tx,ty,1)

+-        -+
| a  c  tx |
| b  d  ty |
| 0  0  1  |
+-        -+
```
如果我们将`matrix(a,b,c,d,tx,ty)`效果应用于点`(x,y)`则会得到`(a*x+c*y+tx, b*x+d*y+ty)`
```
        *(a,b,c,d,tx,ty)
(x, y)--------------------->(a*x+c*y+tx, b*x+d*y+ty)

+-        -+   +- -+   +-          -+
| a  c  tx |   | x |   | a*x+c*y+tx |
| b  d  ty | . | y | = | b*x+d*y+ty |
| 0  0  1  |   | 1 |   |     1      |
+-        -+   +- -+   +-          -+
```
### matrix3d
`matrix2d(a,b,0,c,d,0,tx,ty,1)` 事实上是 `matrix3d(a,b,0,0,c,d,0,0,0,0,1,0,tx,ty,0,1)` 的简写。
所以上面又可以写为
```
matrix(a,b,c,d,tx,ty)
=== matrix2d(a,b,0,c,d,0,tx,ty,1)
=== matrix3d(a,b,0,0,c,d,0,0,0,0,1,0,tx,ty,0,1);

+-           -+
| a  c  0  tx |
| b  d  0  ty |
| 0  0  1  0  |
| 0  0  0  1  |
+-           -+   
```
如果我们将和上面相同的2d变换`matrix(a,b,c,d,tx,ty)`效果应用于点`(x,y,z)`则会得到`(a*x+c*y+tx, b*x+d*y+ty, z)`
```
            *(a,b,c,d,tx,ty)
(x, y, z)--------------------->(a*x+c*y+tx, b*x+d*y+ty, z)

+-           -+   +- -+   +-          -+
| a  c  0  tx |   | x |   | a*x+c*y+tx |
| b  d  0  ty | . | y | = | b*x+d*y+ty |
| 0  0  1  0  |   | z |   |     z      |
| 0  0  0  1  |   | 1 |   |     1      |
+-           -+   +- -+   +-          -+
```
可见坐标的z值是不会改变的
### 3d 页面坐标系
3d看时页面增加了一个z轴指向屏幕外
```
            x
        +------->
       /|
    z / |  html
     / y|
        v
```
### perspective & perspective()
页面默认处于z=0处，要调整页面位置可以设置`perspective`，这个`css`属性用于控制元素距离我们的距离。可能有人已经注意到`transform`里有一个`perspective()`，他们表示不同的含义。`perspective`用于调整观察内部元素的距离，`perspective()`用于调整元素本身距离我们的距离。
```
perspective(d) === matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,−1/d,1)
--------------------
+-             -+
| 1  0    0   0 |
| 0  1    0   0 |
| 0  0    1   0 |
| 0  0  −1/d  1 |
+-             -+ 

               *perspective(d)
(x, y, z, 1)-------------------->(x, y, z, 1-z/d)
+-             -+   +- -+   +-     -+
| 1  0    0   0 |   | x |   |   x   |
| 0  1    0   0 | . | y | = |   y   |
| 0  0    1   0 |   | z |   |   z   |
| 0  0  −1/d  1 |   | 1 |   | 1-z/d |
+-             -+   +- -+   +-     -+
```
`perspective()`似乎没有改变坐标，它改变了平时一直为1的常量，这个常量会怎么影响物体呢？我们拿拥有`perspective`的物体做一次2d变换
```
                *(a,b,0,0,c,d,0,0,0,0,1,0,tx,ty,0,1)
(x,y,z,1-z/d)----------------------------------------->(a*x+c*y+tx*(1-z/d),b*x+d*y+ty*(1-z/d),z,1-z/d)

+-           -+   +-     -+   +-                  -+
| a  c  0  tx |   |   x   |   | a*x+c*y+tx*(1-z/d) |
| b  d  0  ty | . |   y   | = | b*x+d*y+ty*(1-z/d) |
| 0  0  1   0 |   |   z   |   |          z         |
| 0  0  0   1 |   | 1-z/d |   |        1-z/d       |
+-           -+   +-     -+   +-                  -+
```
可见`perspective()`并不直接改变元素大小，而是通过改变`tx`,`ty`,`tz`的比例间接改变元素大小。

上面的图利用[Martix3D ASCII](/apps/matrix3d)生成，在第二个输入框输入`(x,y,z,1-z/d)`然后回车(`[Enter]`)，再输入`(a,b,c,d,tx,ty)`然后点击`补全`按钮然后回车(`[Enter]`)，点击`生成`即可生成此ASCII图。
### rotate3d(x, y, z, a)
`x`是`number`类型值，描述旋转轴向量的x坐标。
`y`是`number`类型值，描述旋转轴向量的y坐标。
`z`是`number`类型值，描述旋转轴向量的z坐标。
`a`即`angle`，代表旋转的角度。正角度表示顺时针旋转，负角度表示逆时针旋转。
```
roate3d(x,y,z,a)

+-                                                                               -+
|   1+(1-cos(a))*(x*x-1)     z*sin(a)+x*y*(1-cos(a))  -y*sin(a)+x*z*(1-cos(a))  0 |
| -z*sin(a)+x*y*(1-cos(a))    1+(1-cos(a))*(y*y-1)     x*sin(a)+y*z*(1-cos(a))  0 |
|  y*sin(a)+x*z*(1-cos(a))  -x*sin(a)+y*z*(1-cos(a))    1+(1-cos(a))*(z*z-1)    0 |
|             0                         0                         0             1 |
+-                                                                               -+
```
上面的图还是利用[Martix3D ASCII](/apps/matrix3d)生成，第一个框输入`(1+(1-cos(a))*(x*x-1),-z*sin(a)+x*y*(1-cos(a)),y*sin(a)+x*z*(1-cos(a)),0,z*sin(a)+x*y*(1-cos(a)),1+(1-cos(a))*(y*y-1),-x*sin(a)+y*z*(1-cos(a)),0,-y*sin(a)+x*z*(1-cos(a)),x*sin(a)+y*z*(1-cos(a)),1+(1-cos(a))*(z*z-1),0,0,0,0,1)`生成
### rotate特化
上面的是针对任意轴旋转，但实际上我们应用更广的是针对特定的轴做旋转，比如[design 3d](/apps/design)事实上是将xy的旋转与z的旋转完全分离了。

针对 X，Y，Z做旋转。
```
rotateX(a) === (1,0,0,0,0,cos(a),sin(a),0,0,-sin(a),cos(a),0,0,0,0,1)
+-                     -+
| 1     0       0     0 |
| 0  cos(a)  -sin(a)  0 |
| 0  sin(a)   cos(a)  0 |
| 0     0       0     1 |
+-                     -+

rotateY(a) === (cos(a),0,-sin(a),0,0,1,0,0,sin(a),0,cos(a),0,0,0,0,1)
+-                     -+
|  cos(a)  0  sin(a)  0 |
|    0     1     0    0 |
| -sin(a)  0  cos(a)  0 |
|    0     0     0    1 |
+-                     -+

rotateZ(a) === (cos(a),sin(a),0,0,-sin(a),cos(a),0,0,0,0,1,0,0,0,0,1)
+-                     -+
| cos(a)  -sin(a)  0  0 |
| sin(a)   cos(a)  0  0 |
|    0       0     1  0 |
|    0       0     0  1 |
+-                     -+

```
看的出是很简单容易理解的变幻，那我们试试复合X旋转和Y旋转。
```
rotateXY(x,y)

(1,0,0,0,0,cos(x),sin(x),0,0,-sin(x),cos(x),0,0,0,0,1)
------------------------------------------------------------>
*(cos(y),0,-sin(y),0,0,1,0,0,sin(y),0,cos(y),0,0,0,0,1)
------------------------------------------------------------>
(cos(y),0,-sin(y),0,sin(y)*sin(x),cos(x),cos(y)*sin(x),0,sin(y)*cos(x),-sin(x),cos(y)*cos(x),0,0,0,0,1)

+-                     -+   +-                     -+   +-                                        -+
|  cos(y)  0  sin(y)  0 |   | 1     0       0     0 |   |  cos(y)  sin(y)*sin(x)  sin(y)*cos(x)  0 |
|    0     1     0    0 | . | 0  cos(x)  -sin(x)  0 | = |    0         cos(x)        -sin(x)     0 |
| -sin(y)  0  cos(y)  0 |   | 0  sin(x)   cos(x)  0 |   | -sin(y)  cos(y)*sin(x)  cos(y)*cos(x)  0 |
|    0     0     0    1 |   | 0     0       0     1 |   |    0           0              0        1 |
+-                     -+   +-                     -+   +-                                        -+
```
似乎变得稍微复杂了一点，不能一眼看出新的变换是什么效果。不过在实际编码中，可以将操作分为两部来做，可以避免直接写复合操作，且变换效果是一样的。在需要符合操作的敌方也可以利用工具直接生成。
### scale3d(sx, sy, sz)
这个变换非常简单，也是最容易理解的变换之一
```
scale3d(sx, sy, sz) === (sx,0,0,0,0,sy,0,0,0,0,sz,0,0,0,0,1)
+-             -+
| sx   0   0  0 |
|  0  sy   0  0 |
|  0   0  sz  0 |
|  0   0   0  1 |
+-             -+
```
我们应用到`(x,y,z)`试试
```
            *(sx,0,0,0,0,sy,0,0,0,0,sz,0,0,0,0,1)
(x,y,z,1)------------------------------------------>(sx*x,sy*y,sz*z,1)

+-             -+   +- -+   +-    -+
| sx   0   0  0 |   | x |   | sx*x |
|  0  sy   0  0 | . | y | = | sy*y |
|  0   0  sz  0 |   | z |   | sz*z |
|  0   0   0  1 |   | 1 |   |   1  |
+-             -+   +- -+   +-    -+
```
结果令人欣慰，不出我们所料，变换结果很容易理解
### translate3d(tx, ty, tz)
同样简单的变换
```
translate3d(tx, ty, tz) === (1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1)
+-           -+
| 1  0  0  tx |
| 0  1  0  ty |
| 0  0  1  tz |
| 0  0  0   1 |
+-           -+
```
我们应用到`(x,y,z)`试试
```
            *(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1)
(x,y,z,1)------------------------------------------>(x+tx,y+ty,z+tz,1)

+-           -+   +- -+   +-    -+
| 1  0  0  tx |   | x |   | x+tx |
| 0  1  0  ty | . | y | = | y+ty |
| 0  0  1  tz |   | z |   | z+tz |
| 0  0  0   1 |   | 1 |   |   1  |
+-           -+   +- -+   +-    -+
```
一样简单的结果
### skew(ax, ay)
和上面所有变换都在直角坐标有所不同，这个是用于拉伸坐标的。举个简单的图理解。
```
+-----+                     +-----+   
|     |      skewX(30deg)    \     \  
|     |  ------------------>  \     \ 
+-----+                        +-----+
```
是不是很容易理解了，就和我们画坐标系是45度一样的道理。

上面的图还是利用[Martix3D ASCII](/apps/matrix3d)生成，输出框输入原图形，在添加框输入变形后的图，点击添加后会自动补齐空格加到右侧，长按还可持续添加。
```
            *(1,tan(ay),0,0,tan(ax),1,0,0,0,0,1,0,0,0,0,1)
(x,y,z,1)--------------------------------------------------->(x+tan(ax)*y,tan(ay)*x+y,z,1)

+-                      -+   +- -+   +-           -+
|    1     tan(ax)  0  0 |   | x |   | x+tan(ax)*y |
| tan(ay)     1     0  0 | . | y | = | tan(ay)*x+y |
|    0        0     1  0 |   | z |   |      z      |
|    0        0     0  1 |   | 1 |   |      1      |
+-                      -+   +- -+   +-           -+
```
## 总结
3D很酷，但变换矩阵似乎很难，但其实并不，只要拆解开来看，理解运算过程，是很容易的。

本片文章从原理了解了CSS 3D变换的过程，下面我们开始实践，用学到的知识构建应用吧。[CSS matrix3d 旋转3D物体（实践篇）](/blog/matrix3d-2)